<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>汇编语言 | 1!5!</title><meta name="keywords" content="汇编语言"><meta name="author" content="phrara"><meta name="copyright" content="phrara"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="汇编知识汇编语言的组成   汇编指令：机器码的助记符，有对应的机器码   伪指令：为汇编过程提供控制信息，没有对应的机器码，计算机并不执行，编译器执行   其他符号：由编译器识别，没有对应的机器码  8086PC 内存地址分配8086PC 具有宽度为20的地址总线，宽度为16的数据总线 00000 ~ 9FFFF     主存储器RAM A0000 ~ BFFFF    显存地址 C0000 ~">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言">
<meta property="og:url" content="http://example.com/post/8e41db39/index.html">
<meta property="og:site_name" content="1!5!">
<meta property="og:description" content="汇编知识汇编语言的组成   汇编指令：机器码的助记符，有对应的机器码   伪指令：为汇编过程提供控制信息，没有对应的机器码，计算机并不执行，编译器执行   其他符号：由编译器识别，没有对应的机器码  8086PC 内存地址分配8086PC 具有宽度为20的地址总线，宽度为16的数据总线 00000 ~ 9FFFF     主存储器RAM A0000 ~ BFFFF    显存地址 C0000 ~">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/c4.png">
<meta property="article:published_time" content="2022-09-08T13:27:48.000Z">
<meta property="article:modified_time" content="2022-09-08T13:47:19.909Z">
<meta property="article:author" content="phrara">
<meta property="article:tag" content="汇编语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/c4.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/8e41db39/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '汇编语言',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-08 21:47:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/photo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gifts</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/c4.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">1!5!</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gifts</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">汇编语言</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-09-08T13:27:48.000Z" title="Created 2022-09-08 21:27:48">2022-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-09-08T13:47:19.909Z" title="Updated 2022-09-08 21:47:19">2022-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82/">计算机底层</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="汇编语言"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="汇编知识"><a href="#汇编知识" class="headerlink" title="汇编知识"></a>汇编知识</h1><h4 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h4><ol>
<li>  汇编指令：机器码的助记符，有对应的机器码</li>
<li>  伪指令：为汇编过程提供控制信息，没有对应的机器码，计算机并不执行，编译器执行</li>
<li>  其他符号：由编译器识别，没有对应的机器码</li>
</ol>
<h4 id="8086PC-内存地址分配"><a href="#8086PC-内存地址分配" class="headerlink" title="8086PC 内存地址分配"></a>8086PC 内存地址分配</h4><p>8086PC 具有宽度为20的地址总线，宽度为16的数据总线</p>
<p>00000 ~ 9FFFF     主存储器RAM</p>
<p>A0000 ~ BFFFF    显存地址</p>
<p>C0000 ~ FFFFF    各类ROM</p>
<h4 id="Debug程序"><a href="#Debug程序" class="headerlink" title="Debug程序"></a>Debug程序</h4><ul>
<li>  -u : check a memory segment in assembly way    以数据的形式查看一段内存</li>
<li>  -d : check a memory segment in data way             以代码的形式查看一段内存</li>
<li>  -e : edit a memory segment                    编辑一段内存地址，使用空格进行后移                   </li>
<li>  -a : input a series of assembly code              默认在cs:ip位置处编写一段汇编代码，可指定其他内存位置</li>
<li>  -r : check all registers or update a register       查看所用通用寄存器或者修改某寄存器的值</li>
<li>  -t : debug a programme step by step with going into sub programme          单步调试，进入子程序</li>
<li>  -p : debug a programme step by step without going into sub programme      单步调试，不进入子程序，跳过循环</li>
<li>  -n : rename a file           文件重命名</li>
<li>  -g : don’t stop executing the programme until the target address you set comes           运行程序到你设定的地址</li>
</ul>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>​    是CPU内部的存储器，是用来暂存计算数据及结果，是程序员可以进行操纵的空间，通过操纵寄存器进而达到操纵CPU的目的</p>
<p>对于8086CPU来说，总共有14个</p>
<h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>其中通用寄存器有4个{AX，BX，CX，DX}，用来存放数据，每一个通用寄存器是由高低两个8位寄存器组成的16位寄存器{AX = AH + AL}；</p>
<blockquote>
<p>EAX : 32位寄存器                  RAX : 64位寄存器 </p>
<p>EAX 位于 RAX 的低32位</p>
<p>AX 位于 EAX 的低16位</p>
</blockquote>
<p>进行8位运算时，两个8位寄存器互不影响，不进位不借位，进位值与借位值存在标志寄存器的<strong>CF标志位</strong>中</p>
<p>进行16位运算时，  高位溢出舍弃</p>
<h4 id="MOV-amp-ADD-amp-SUB-指令"><a href="#MOV-amp-ADD-amp-SUB-指令" class="headerlink" title="MOV &amp; ADD &amp; SUB 指令"></a>MOV &amp; ADD &amp; SUB 指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx      ; 将ax中的数据与bx相加后结果送入ax</span><br><span class="line">mov ax,5FC5    ; 将ax的值改为5fc5</span><br><span class="line">mov al,bh      ; 将ax的低8位的值改为bx高8位的值</span><br><span class="line">add ax,05A6    ; ax的值加上05a6后，送入ax中</span><br><span class="line">add bh,al      ; 将bx的高8位加上ax的低8位</span><br><span class="line">sub ax,ax      ; 减法运算</span><br></pre></td></tr></table></figure>

<h3 id="地址寄存器"><a href="#地址寄存器" class="headerlink" title="地址寄存器"></a>地址寄存器</h3><ul>
<li><p>段地址寄存器</p>
<p>  {CS，DS，SS，ES} = {代码段，数据段，堆栈段，其他段}</p>
</li>
<li><p>偏移地址寄存器</p>
<p>  {SP，BP，SI，DI，IP，BX} = {，，，，指令指针，}</p>
</li>
<li><p>设计目的</p>
<p>  8086CPU地址总线宽度为20，而寄存器位长16，那么就需要用两个寄存器来存一个物理地址</p>
</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">PhysicalAddr</span> <span class="operator">=</span> <span class="variable">SegmentAddr</span> <span class="operator">*</span> <span class="number">10</span><span class="variable">h</span> <span class="operator">+</span> <span class="variable">OffsetAddr</span></span><br></pre></td></tr></table></figure>

<h3 id="CS-IP-代码段"><a href="#CS-IP-代码段" class="headerlink" title="CS : IP 代码段"></a>CS : IP 代码段</h3><blockquote>
<p>  代码段寄存器 : 指令指针寄存器</p>
</blockquote>
<p>CPU将CS:IP指向的内存单元中的内容当做代码执行 </p>
<p>指令执行过程：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓冲区</span><br><span class="line">2. IP = IP + Length(Instruction) 从而指向下一条指令的地址</span><br><span class="line">3. 执行指令，转到步骤 1</span><br></pre></td></tr></table></figure>

<p>在8086CPU加电启动或复位后，CS被置为FFFFH，IP被置为0000H</p>
<h4 id="JMP-指令"><a href="#JMP-指令" class="headerlink" title="JMP 指令"></a>JMP 指令</h4><p>转移指令，修改CS:IP的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp 2000:0010    ; 修改CS为2000，修改IP为0010</span><br><span class="line">jmp ax           ; 修改IP为AX中存储的值</span><br></pre></td></tr></table></figure>

<h3 id="DS-Offset-数据段"><a href="#DS-Offset-数据段" class="headerlink" title="DS : [Offset] 数据段"></a>DS : [Offset] 数据段</h3><blockquote>
<p>  数据段寄存器 : [偏移地址]</p>
</blockquote>
<p>CPU将DS:[Offset]指向的内存地址中的内容当做数据读写（<u><strong>需要注意小端序还是大端序</strong></u>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,3001</span><br><span class="line">mov ds,bx         ; 将BX中存储的段地址送入DS数据段寄存器中，8086不允许使用MOV指令直接给段寄存器赋值</span><br><span class="line">mov ax,[0101]     ; 将内存中地址为 DS * 10h + 0101h 中的数据送入AX中</span><br><span class="line">mov [0102],ax     ; 将AX中的数据送入到内存地位为 DS * 10h + 0102h 的地方</span><br></pre></td></tr></table></figure>

<h3 id="SS-SP-堆栈段"><a href="#SS-SP-堆栈段" class="headerlink" title="SS : SP 堆栈段"></a>SS : SP 堆栈段</h3><blockquote>
<p>  堆栈段寄存器 : 栈顶指针寄存器</p>
</blockquote>
<p>8086CPU的入栈操作和出栈操作都是以<strong>字</strong>为单位进行的；入栈时，栈顶由高地址向低地址的方向增长(小端序)</p>
<h4 id="PUSH-amp-POP-指令"><a href="#PUSH-amp-POP-指令" class="headerlink" title="PUSH &amp; POP 指令"></a>PUSH &amp; POP 指令</h4><p>出栈 &amp; 入栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;指定栈顶界限，假定栈段范围为10000 ~ 1001F</span><br><span class="line">mov ax,1000</span><br><span class="line">mov ss,ax</span><br><span class="line">;设置栈顶指针,空栈时,栈顶指针指向栈底后一位地址</span><br><span class="line">mov sp,0020</span><br><span class="line">;入栈：</span><br><span class="line">;	SP = SP - 2       </span><br><span class="line">mov bx,3FFF</span><br><span class="line">push bx</span><br><span class="line">push ds</span><br><span class="line">push [0]</span><br><span class="line">;出栈：</span><br><span class="line">;	SP = SP + 2</span><br><span class="line">pop [0]</span><br><span class="line">pop ds</span><br><span class="line">pop bx</span><br></pre></td></tr></table></figure>

<p><strong>当执行修改SS堆栈段寄存器的值时，下一条指令也会紧接着执行</strong></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">; 数据段</span><br><span class="line">data segment</span><br><span class="line">date ends</span><br><span class="line">; 堆栈段</span><br><span class="line">stack segment stack</span><br><span class="line">stack ends</span><br><span class="line">; 代码段</span><br><span class="line">code segment</span><br><span class="line">	</span><br><span class="line">	mov ax,4500H</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,1000H</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,0020H</span><br><span class="line">	</span><br><span class="line">	mov ax,0D200H      ; 在汇编源程序中，数据不能以字母开头，若最高位＞9时，需要在前面补0</span><br><span class="line">	mov ds:[0],ax</span><br><span class="line">    push ds:[0]</span><br><span class="line">    pop bx</span><br><span class="line">    mov ds:[2],bx</span><br><span class="line">	</span><br><span class="line">	; 返回上级程序</span><br><span class="line">	mov ax,4c00H</span><br><span class="line">	int 21H</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="BX-amp-LOOP-指令"><a href="#BX-amp-LOOP-指令" class="headerlink" title="[BX] &amp; LOOP 指令"></a>[BX] &amp; LOOP 指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0010H   </span><br><span class="line">mov ax,50F0H</span><br><span class="line">mov ds:[bx],ax   ; 将bx寄存器中的数据当做地址偏移量</span><br></pre></td></tr></table></figure>

<p>​        CX寄存器中的值可作为loop指令循环次数，每次减一，知道减为零结束循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,1000H</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,5H</span><br><span class="line">	</span><br><span class="line">	mov al,ds:[bx]</span><br><span class="line">	mov ah,0H</span><br><span class="line">	mov dx,0H</span><br><span class="line">	</span><br><span class="line">	mov cx,5            ; 初始化循环次数</span><br><span class="line">s: 	add dx,ax           ; 定义循环体</span><br><span class="line">	loop s              ; 开始循环</span><br><span class="line">	</span><br><span class="line">	mov ax,004cH</span><br><span class="line">	int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>综合运用[bx]&amp;loop</p>
<h3 id="INC-指令"><a href="#INC-指令" class="headerlink" title="INC 指令"></a>INC 指令</h3><p>​    数值自增一</p>
<h3 id="DEC-指令"><a href="#DEC-指令" class="headerlink" title="DEC 指令"></a>DEC 指令</h3><p>​    数值自减一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; 	计算从10000H ~ 1000aH地址中所有数值的和，储存在dx中</span><br><span class="line">	</span><br><span class="line">	mov ax,1000H</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,0H</span><br><span class="line"></span><br><span class="line">	mov dx,0H</span><br><span class="line">	mov cx,0aH</span><br><span class="line"></span><br><span class="line">s: 	mov al,ds:[bx]</span><br><span class="line">	mov ah,0H</span><br><span class="line">	add dx,ax</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h2 id="DW-伪指令-amp-start-标号"><a href="#DW-伪指令-amp-start-标号" class="headerlink" title="DW 伪指令 &amp; start 标号"></a>DW 伪指令 &amp; start 标号</h2><p>定义字型数据(define word)，可在代码段中存放提前定义好的数据</p>
<p><strong>start</strong> 标号用来标识程序的入口，即是初始化CS:IP的值，用 <strong>end</strong> 指令来声明<strong>start</strong>标号的作用（程序入口）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	</span><br><span class="line">	; 定义数据</span><br><span class="line">	dw 0123H,0a446H,5FF6H</span><br><span class="line">	</span><br><span class="line">	; 代码</span><br><span class="line">start:	mov bx,0</span><br><span class="line">		mov ax,0</span><br><span class="line">		mov cx,3</span><br><span class="line">		</span><br><span class="line">s:		add ax,cs:[bx]</span><br><span class="line">		add bx,2H</span><br><span class="line">		loop s</span><br><span class="line">	</span><br><span class="line">		mov ax,4c00H</span><br><span class="line">		int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>​    将数据、代码、栈三段分立，方便管理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw 0123H,0456H,0789H,0abcH,0defH</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment stack</span><br><span class="line">	dw 0H,0H,0H,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax         ; 分配数据段</span><br><span class="line">		mov ax,stack</span><br><span class="line">		mov ss,ax         ; 分配栈段</span><br><span class="line">		mov sp,0eH</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00H</span><br><span class="line">		int 21H</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h2 id="地址定位与数据处理"><a href="#地址定位与数据处理" class="headerlink" title="地址定位与数据处理"></a>地址定位与数据处理</h2><h3 id="AND-amp-OR-指令"><a href="#AND-amp-OR-指令" class="headerlink" title="AND &amp; OR 指令"></a>AND &amp; OR 指令</h3><p>​    二进制逻辑与或运算</p>
<h3 id="XOR-指令"><a href="#XOR-指令" class="headerlink" title="XOR 指令"></a>XOR 指令</h3><p>​    异或运算，常用于main函数设置返回值0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xor eax,eax     ; 该命令执行速度比 mov ax,0 要快</span><br></pre></td></tr></table></figure>

<h3 id="字符串型数据-amp-DB-伪指令"><a href="#字符串型数据-amp-DB-伪指令" class="headerlink" title="字符串型数据 &amp; DB 伪指令"></a>字符串型数据 &amp; DB 伪指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">	db &#x27;string&#x27;</span><br><span class="line">data ends</span><br><span class="line">; low -&gt; up</span><br><span class="line">or al,00100000</span><br><span class="line">; up -&gt; low</span><br><span class="line">and al,11011111</span><br></pre></td></tr></table></figure>

<h3 id="灵活定位-amp-DI-amp-SI-amp-BP"><a href="#灵活定位-amp-DI-amp-SI-amp-BP" class="headerlink" title="灵活定位 &amp; DI &amp; SI &amp; BP"></a>灵活定位 &amp; DI &amp; SI &amp; BP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[bx+100]</span><br><span class="line">mov ax,ds:[bx+di]</span><br><span class="line">mov ax,ds:[bx][si]</span><br><span class="line">mov ax,ds:[bx+si+100]</span><br><span class="line">mov ax,ds:[bx][si].100</span><br><span class="line">mov ax,ds:[bp+si+100]</span><br><span class="line">mov ax,ds:[bp][si].100</span><br></pre></td></tr></table></figure>

<p>SI &amp; DI ：16位寄存器，无法分割为两个8位寄存器</p>
<p>BP：<a href="#BP%E5%AF%84%E5%AD%98%E5%99%A8">见此处</a></p>
<h3 id="X-PTR"><a href="#X-PTR" class="headerlink" title="X PTR"></a>X PTR</h3><p><strong>指明数据长度的方式</strong>：</p>
<ul>
<li><p>通过寄存器名指明数据长度</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1H</span><br><span class="line">mov al,1H</span><br></pre></td></tr></table></figure>

</li>
<li><p>  通过操作符 X PTR 指明数据长度</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1H</span><br><span class="line">mov byte ptr ds:[2],1H</span><br><span class="line">mov byte ptr ds:[bx+si+10],&#x27;F&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="DIV-指令"><a href="#DIV-指令" class="headerlink" title="DIV 指令"></a>DIV 指令</h3><ol>
<li>  除数：在寄存器或内存</li>
<li>被除数：默认在AX或DX<ul>
<li>  除数为8位，被除数为16位，则被除数放在AX</li>
<li>  除数为16位，被除数为32位，则被除数在DX与AX，DX放高位，AX放低位</li>
</ul>
</li>
<li>结果：<ul>
<li>  若除数为8位，则al存放商，ah存放余数</li>
<li>  若除数为16位，则ax存放商，dx存放余数</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; 计算 100001 / 100</span><br><span class="line">; 100001 =&gt; 186a1H</span><br><span class="line">mov dx,1H</span><br><span class="line">mov ax,86a1H</span><br><span class="line">mov word ptr ds:[bx+si+10],100</span><br><span class="line">div word ptr ds:[bx+si+10]</span><br></pre></td></tr></table></figure>

<h3 id="DD-伪指令"><a href="#DD-伪指令" class="headerlink" title="DD 伪指令"></a>DD 伪指令</h3><p>用来定义DWORD（double word）双字型数据</p>
<h3 id="DUP-伪指令"><a href="#DUP-伪指令" class="headerlink" title="DUP 伪指令"></a>DUP 伪指令</h3><p>与db、dw、dd等数据定义伪指令配合使用，进行重复数据的定义</p>
<ul>
<li>  db 重复次数 dup (被重复的字节型数据)</li>
<li>  dw 重复次数 dup (被重复的字型数据)</li>
<li>  dd 重复次数 dup (被重复的双字型数据)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (&#x27;12&#x27;)    ;   db &#x27;121212&#x27;</span><br><span class="line">db 5 dup (10H)     ;   db 10h,10h,10h,10h,10h</span><br><span class="line">dw 2 dup (5f5fH)   ;   dw 5f5fH,5f5fH</span><br><span class="line">dd 2 dup(12H)      ;   dd 00000012H,00000012H</span><br></pre></td></tr></table></figure>

<h2 id="JMP指令原理"><a href="#JMP指令原理" class="headerlink" title="JMP指令原理"></a>JMP指令原理</h2><h3 id="OFFSET-伪指令"><a href="#OFFSET-伪指令" class="headerlink" title="OFFSET 伪指令"></a>OFFSET 伪指令</h3><p>取得标号的偏移地址，<strong>不能用 OFFSET 获得堆栈参数的地址，因为 OFFSET 只适用于编译时已知的地址。下面的语句无法汇编</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">start:	</span><br><span class="line">		mov ax,offset start</span><br></pre></td></tr></table></figure>

<h3 id="JMP指令的用法"><a href="#JMP指令的用法" class="headerlink" title="JMP指令的用法"></a>JMP指令的用法</h3><ol>
<li><p>数值指明目的地址</p>
<ul>
<li><p>同时修改cs : ip</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 1000:0000</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>段内短转移（机器码中不出现目的地址，只出现相对位移，**<u>==该相对位移在编译时确定==</u>**）</p>
<p>  转移位移为8位，-128,127</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">s:</span><br><span class="line">	mov ax,10H</span><br><span class="line">	jmp short s          ; 使用相对距离差修改ip的值，ip = ip + (标号地址 - jmp后下一条指令初地址) </span><br><span class="line">	mov bx,11H</span><br></pre></td></tr></table></figure></li>
<li><p>段内近转移</p>
<p>  转移位移为16位，-32768,32767（机器码中不出现目的地址，……同短转移）</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">s:</span><br><span class="line">	mov ax,10H</span><br><span class="line">	jmp near ptr s</span><br><span class="line">	mov bx,11H</span><br></pre></td></tr></table></figure></li>
<li><p>段间转移（远转移）</p>
<p>  同时修改CS:IP，cs = 标号所在段的段地址，ip = 标号在所在段的偏移地址</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">acode segment</span><br><span class="line">sa:</span><br><span class="line">	mov ax,10H</span><br><span class="line">	jmp far ptr sb</span><br><span class="line">acode ends</span><br><span class="line"></span><br><span class="line">bcode segment</span><br><span class="line">sb:</span><br><span class="line">	mov bx,11H</span><br><span class="line">bcode ends</span><br></pre></td></tr></table></figure>

</li>
<li><p>转移地址在寄存器中</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,10F1H</span><br><span class="line">jmp ax</span><br></pre></td></tr></table></figure>

</li>
<li><p>转移地址在内存中</p>
<ul>
<li><p>内存单元中存有一个字型数据，即为目的地址的偏移地址（段内转移但非近转移）</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds:[1],ax</span><br><span class="line">jmp word ptr ds:[1]</span><br></pre></td></tr></table></figure></li>
<li><p>内存单元中存有一个双字型数据，高位为目的地址的段地址，低位为偏移地址（段间转移）</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0H</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="有条件转移指令"><a href="#有条件转移指令" class="headerlink" title="有条件转移指令"></a>有条件转移指令</h3><p>所有的条件转移指令都是短转移，在对应机器码中不出现目的地址，只出现相对位移，在编译时确定</p>
<ul>
<li><p>jcxz 指令</p>
<p>  功能上等同于在段内短转移之前判断CX是否等于0，若cx == 0，则跳转，若cx != 0，则不跳转</p>
</li>
<li><p>loop 指令</p>
<p>  本质上也是条件转移指令，条件与jcxz相反，且伴随着cx的递减</p>
</li>
<li><p>检测比较结果的条件转移指令（根据**<u>==无符号数==</u>**的比较结果进行转移）</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">含义</th>
<th align="center">相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JE</td>
<td align="center">等于则转移</td>
<td align="center">ZF = 1</td>
</tr>
<tr>
<td align="center">JNE</td>
<td align="center">不等于则转移</td>
<td align="center">ZF = 0</td>
</tr>
<tr>
<td align="center">JB</td>
<td align="center">低于则转移</td>
<td align="center">CF = 1</td>
</tr>
<tr>
<td align="center">JNB</td>
<td align="center">不低于则转移</td>
<td align="center">CF = 0</td>
</tr>
<tr>
<td align="center">JA</td>
<td align="center">高于则转移</td>
<td align="center">CF = 0  &amp;&amp;  ZF = 0</td>
</tr>
<tr>
<td align="center">JNA</td>
<td align="center">不高于则转移</td>
<td align="center">CF = 1  ||  ZF = 1</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcxz 标号</span><br></pre></td></tr></table></figure>



<h2 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h2><h3 id="RET-amp-RETF-指令"><a href="#RET-amp-RETF-指令" class="headerlink" title="RET &amp; RETF 指令"></a>RET &amp; RETF 指令</h3><p>ret：用栈中的数据修改ip的内容，实现近转移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret </span><br><span class="line">====&gt;   </span><br><span class="line">pop ip</span><br></pre></td></tr></table></figure>

<p>retf：用栈中的数据修改 cs : ip，实现远转移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">retf </span><br><span class="line">====&gt;</span><br><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">====&gt;</span><br><span class="line">mov bx,sp</span><br><span class="line">jmp dword ptr ss:[bx]</span><br><span class="line">add sp,4</span><br></pre></td></tr></table></figure>

<h3 id="CALL-指令"><a href="#CALL-指令" class="headerlink" title="CALL 指令"></a>CALL 指令</h3><p>call：将当前 ip 或 cs : ip 压入栈中，再转移</p>
<ul>
<li><p>进行近转移的call指令</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call fun     ; fun 为本段内某标号</span><br><span class="line">====&gt;</span><br><span class="line">push ip</span><br><span class="line">jmp near ptr fun</span><br></pre></td></tr></table></figure></li>
<li><p>进行远转移的call指令</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call far ptr fun     ; fun 为非本段内某标号</span><br><span class="line">====&gt;</span><br><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp far ptr fun</span><br></pre></td></tr></table></figure></li>
<li><p>目的地址在寄存器的call指令</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call ax      </span><br><span class="line">====&gt;</span><br><span class="line">push ip</span><br><span class="line">jmp ax</span><br></pre></td></tr></table></figure></li>
<li><p>目的地址在内存中的call指令</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call word ptr ds:[bx]              ; 段内转移</span><br><span class="line">====&gt;</span><br><span class="line">push ip</span><br><span class="line">jmp word ptr ds:[bx]</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">call dword ptr ds:[bx]             ; 段间转移（远转移）</span><br><span class="line">====&gt;</span><br><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp dword ptr ds:[bx]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="BP寄存器"><a href="#BP寄存器" class="headerlink" title="BP寄存器"></a>BP寄存器</h3><ul>
<li>  当没有显式指出段地址且偏移量寄存器使用bp时，则段地址默认为SS寄存器中的值，无法分割bp为基址寄存器</li>
<li>  和堆栈指针SP联合使用的，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到</li>
<li>  一般在函数中用来保存进入函数时的sp的栈顶基址每次子函数调用时，系统在开始时都会保存这个两个指针并在函数结束时恢复sp和bp的值。像下面这样：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;在函数进入时:</span><br><span class="line">push bp     ;	保存bp指针</span><br><span class="line">mov bp,sp 	;	将sp指针传给bp，此时bp指向sp的基地址。</span><br><span class="line"></span><br><span class="line">;;;;   函数体   ;;;;</span><br><span class="line"></span><br><span class="line">mov sp,bp   ;	sp回到栈顶</span><br><span class="line">pop bp      ;	bp恢复初始值</span><br><span class="line">ret         ; 	函数返回</span><br></pre></td></tr></table></figure>

<h3 id="参数压栈"><a href="#参数压栈" class="headerlink" title="参数压栈"></a>参数压栈</h3><p>​    调用某些带有参数的函数时，先按参数顺序将参数压栈(参数位于栈高位)，然后再执行<strong>CALL</strong>命令将CS:IP压栈(CS:IP位于栈低位)</p>
<h3 id="LEA-指令"><a href="#LEA-指令" class="headerlink" title="LEA 指令"></a>LEA 指令</h3><p>​    LEA 指令返回间接操作数的地址。由于间接操作数中包含一个或多个寄存器，因此会在运行时计算这些操作数的偏移量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">makeArray PROC</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp,esp</span><br><span class="line">    sub esp, 32            ;myString 位于 EBP-30 的位置</span><br><span class="line">    lea esi, [ebp-30]      ;加载 myString 的地址</span><br><span class="line">    mov ecx, 30            ;循环计数器</span><br><span class="line">LI: mov BYTE PTR [esi]     ;填充一个位置</span><br><span class="line">    inc esi                ;指向下一个元素</span><br><span class="line">    loop LI                ;循环，直到 ECX=0</span><br><span class="line">    add esp, 32            ;删除数组(恢复ESP)</span><br><span class="line">    pop ebp</span><br><span class="line">    ret</span><br><span class="line">makeArray ENDP</span><br></pre></td></tr></table></figure>



<h3 id="MUL-指令"><a href="#MUL-指令" class="headerlink" title="MUL 指令"></a>MUL 指令</h3><ul>
<li>  两数相乘，要么都是8位，要么都是16位</li>
<li>  若是8位，一个默认在AL，另一个在8位寄存器或内存，结果在AX</li>
<li>  若是16位，一个默认在AX，另一个在16位寄存器或内存，高位在DX，低位在AX</li>
</ul>
<h3 id="寄存器冲突问题"><a href="#寄存器冲突问题" class="headerlink" title="寄存器冲突问题"></a>寄存器冲突问题</h3><p>若计数器寄存器 CX 另有用途，无法存放循环次数，那么可以用 jmp 与 jcxz 指令配合代替loop指令，实现有限循环</p>
<hr>
<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>  用来存储相关指令的某些执行结果</li>
<li>  用来为CPU执行相关指令提供行为依据</li>
<li>  用来控制CPU的相关工作方式</li>
</ul>
<blockquote>
<p>  8086CPU的标志寄存器时16位寄存器，其信息是按起作用，每一个位存储的信息通常被称为程序状态字(PSW)</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">15</th>
<th align="center">14</th>
<th align="center">13</th>
<th align="center">12</th>
<th align="center">11</th>
<th align="center">10</th>
<th align="center">9</th>
<th align="center">8</th>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">OF</td>
<td align="center">DF</td>
<td align="center">IF</td>
<td align="center">TF</td>
<td align="center">SF</td>
<td align="center">ZF</td>
<td align="center"></td>
<td align="center">AF</td>
<td align="center"></td>
<td align="center">PF</td>
<td align="center"></td>
<td align="center">CF</td>
</tr>
</tbody></table>
<h3 id="ZF-标志"><a href="#ZF-标志" class="headerlink" title="ZF 标志"></a>ZF 标志</h3><ul>
<li>  位于第  <strong>==6==</strong> 位</li>
<li>  零标志位，记录相关指令执行后，其结果是否为0，若为 ==0== 则ZF = 1，否则ZF = 0；</li>
<li>  在8086CPU指令集中，add、sub、mul、div、inc、or、and 等运算指令一般影响ZF</li>
</ul>
<h3 id="PF-标志"><a href="#PF-标志" class="headerlink" title="PF 标志"></a>PF 标志</h3><ul>
<li>  位于第 <strong>==2==</strong> 位</li>
<li>  奇偶标志位，记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数，若 ==偶== 则 ==1==，若 ==奇== 则 ==0==</li>
</ul>
<h3 id="SF-标志"><a href="#SF-标志" class="headerlink" title="SF 标志"></a>SF 标志</h3><ul>
<li>  位于第 <strong>==7==</strong> 位</li>
<li>  符号标志位，记录相关指令执行后，其结果是否为负，若 ==负== 则 ==1==，若 ==非负== 则 ==0==</li>
</ul>
<h3 id="CF-标志"><a href="#CF-标志" class="headerlink" title="CF 标志"></a>CF 标志</h3><ul>
<li>  位于第 <strong>==0==</strong> 位</li>
<li>  进位标志位，一般情况下，在进行 <u>无符号数</u> 运算的时候，记录了运算结果的最高有效位向更高位的进位值，或借位值</li>
</ul>
<h3 id="OF-标志"><a href="#OF-标志" class="headerlink" title="OF 标志"></a>OF 标志</h3><ul>
<li>  位于第 <strong>==11==</strong> 位</li>
<li>  CPU在进行 <u>有符号数</u> 运算时，若溢出则为 1 ，若未溢出，则为 0 </li>
</ul>
<h3 id="ADC-指令"><a href="#ADC-指令" class="headerlink" title="ADC 指令"></a>ADC 指令</h3><p>adc指令是带进位的加法指令，利用了CF标志位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc ax,bx    ;  ax = ax + bx + CF</span><br></pre></td></tr></table></figure>

<h3 id="SBB-指令"><a href="#SBB-指令" class="headerlink" title="SBB 指令"></a>SBB 指令</h3><p>sbb指令是带借位减法指令，同样利用了CF标志位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb ax,bx    ; ax = ax - bx - CF</span><br></pre></td></tr></table></figure>

<h3 id="CMP-指令"><a href="#CMP-指令" class="headerlink" title="CMP 指令"></a>CMP 指令</h3><p>cmp是比较指令，功能上相当于减法指令，但不保存结果，只影响相关标志位的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,3</span><br><span class="line">mov bx,4</span><br><span class="line">cmp ax,bx</span><br><span class="line">; 相当于执行减法，执行后 ZF = 0，PF = 1，SF = 1,CF = 1,OF = 0</span><br></pre></td></tr></table></figure>

<ul>
<li>  ZF = 1  ==&gt;  ax == bx</li>
<li>  ZF = 0  ==&gt;  ax != bx</li>
<li>  CF = 1  ==&gt;  ax &lt; bx</li>
<li>  CF = 0  ==&gt;  ax &gt;= bx</li>
</ul>
<h3 id="TEST-指令"><a href="#TEST-指令" class="headerlink" title="TEST 指令"></a>TEST 指令</h3><p>test 对两个操作数进行逻辑（按位）与操作，功能上与and指令类似，但不保存结果，只影响相关标志位的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 检查ax的最高位是否为 1</span><br><span class="line">test ax,10000000b</span><br><span class="line">je isNotOne      ; 最高位是 0</span><br><span class="line">jne isOne		 ; 最高位是 1</span><br></pre></td></tr></table></figure>



<h3 id="与标志位相关的条件转移指令"><a href="#与标志位相关的条件转移指令" class="headerlink" title="与标志位相关的条件转移指令"></a>与标志位相关的条件转移指令</h3><p><a href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4">详细见此处</a></p>
<h3 id="DF-标志-amp-串传送指令"><a href="#DF-标志-amp-串传送指令" class="headerlink" title="DF 标志 &amp; 串传送指令"></a>DF 标志 &amp; 串传送指令</h3><ul>
<li>  DF 标志位于第 ==10== 位</li>
<li>  方向标志位，在串处理指令中，控制每次操作后 SI 与 DI 的增减</li>
<li>  若 DF = 0，则每次操作后 SI &amp; DI 递增</li>
<li>  若 DF = 1，则每次操作后 SI &amp; DI 递减</li>
</ul>
<h4 id="MOVSB-指令"><a href="#MOVSB-指令" class="headerlink" title="MOVSB 指令"></a>MOVSB 指令</h4><p>movsb 指令功能是将ds:si指向的内存单元中的一个字节型数据送入es:di；相当于:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; if DF = 1</span><br><span class="line">mov es:[di],byte ptr ds:[si]</span><br><span class="line">dec si</span><br><span class="line">dec di</span><br><span class="line"></span><br><span class="line">; if DF = 0</span><br><span class="line">mov es:[di],byte ptr ds:[si]</span><br><span class="line">inc si</span><br><span class="line">inc di</span><br></pre></td></tr></table></figure>

<h4 id="MOVSW-指令"><a href="#MOVSW-指令" class="headerlink" title="MOVSW 指令"></a>MOVSW 指令</h4><p>movsw 指令与 movsb 指令类似，只是把字节型数据改为字型数据，si 与 di 每次变化两个单位</p>
<h4 id="与-REP-的配合"><a href="#与-REP-的配合" class="headerlink" title="与 REP 的配合"></a>与 REP 的配合</h4><p>上述两种指令都需要与 rep 相配和，实现数据从 DS段 <strong>连续</strong>传送到 ES段 中，本质是由loop循环的实现，循环次数由 CX 的值决定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br><span class="line">====&gt;</span><br><span class="line">s: </span><br><span class="line">	movsb</span><br><span class="line">	loop s</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">rep movsw</span><br><span class="line">====&gt;</span><br><span class="line">s: </span><br><span class="line">	movsw</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>

<h4 id="CLD-amp-STD-指令"><a href="#CLD-amp-STD-指令" class="headerlink" title="CLD &amp; STD 指令"></a>CLD &amp; STD 指令</h4><ul>
<li>  sld 指令：将DF置 0，实现 si 与 di 的自增</li>
<li>  std 指令：将DF置 1，实现 si 与 di 的自减</li>
</ul>
<h3 id="PUSHF-amp-POPF-指令"><a href="#PUSHF-amp-POPF-指令" class="headerlink" title="PUSHF &amp; POPF 指令"></a>PUSHF &amp; POPF 指令</h3><p>pushf的功能是将标志寄存器中的值压栈，而popf是将栈中的数据弹出并送入标志寄存器中</p>
<h3 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a>标志寄存器在Debug中的表示</h3><table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">置一</th>
<th align="center">置零</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OF</td>
<td align="center">OV</td>
<td align="center">NV</td>
</tr>
<tr>
<td align="center">SF</td>
<td align="center">NG</td>
<td align="center">PL</td>
</tr>
<tr>
<td align="center">ZF</td>
<td align="center">ZR</td>
<td align="center">NZ</td>
</tr>
<tr>
<td align="center">PF</td>
<td align="center">PE</td>
<td align="center">PO</td>
</tr>
<tr>
<td align="center">CF</td>
<td align="center">CY</td>
<td align="center">NC</td>
</tr>
<tr>
<td align="center">DF</td>
<td align="center">DN</td>
<td align="center">UP</td>
</tr>
</tbody></table>
<hr>
<h2 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h2><h1 id="32位逆向"><a href="#32位逆向" class="headerlink" title="32位逆向"></a>32位逆向</h1><h2 id="小端序-amp-大端序"><a href="#小端序-amp-大端序" class="headerlink" title="小端序&amp;大端序"></a>小端序&amp;大端序</h2><p>地址高位存数据高位 ===》 小端序</p>
<p>地址高位存地址低位 ===》 大端序</p>
<h2 id="IA-32寄存器"><a href="#IA-32寄存器" class="headerlink" title="IA-32寄存器"></a>IA-32寄存器</h2><h3 id="基本程序运行寄存器"><a href="#基本程序运行寄存器" class="headerlink" title="基本程序运行寄存器"></a>基本程序运行寄存器</h3><ul>
<li>  通用寄存器{EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP}</li>
<li>  段寄存器{CS，DS，SS，ES，FS，GS}</li>
<li>  程序状态与控制寄存器{EFLAGS}</li>
<li>  指令指针寄存器{EIP}</li>
</ul>
<blockquote>
<p>Tips:</p>
<ol>
<li>  EAX一般用于函数返回值中，所有Win32 API函数都会先把返回值保存在EAX中再返回</li>
<li>  ES，FS，GS：附加数据段</li>
</ol>
</blockquote>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><ul>
<li>  cdecl：调用者负责清理栈中的参数</li>
<li>  stdcall：被调用者负责清理栈中的参数</li>
</ul>
<h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><img src="https://img-blog.csdnimg.cn/20201210163828181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW5nX2Nt,size_16,color_FFFFFF,t_70" alt="img" style="zoom:100%;">

<h3 id="DOS-头"><a href="#DOS-头" class="headerlink" title="DOS 头"></a>DOS 头</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释掉的不需要重点分析</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span>&#123;</span></span><br><span class="line">    <span class="number">0X00</span> WORD e_magic;      <span class="comment">//※Magic DOS signature MZ(4Dh 5Ah):MZ标记:用于标记是否是可执行文件</span></span><br><span class="line">    <span class="comment">//0X02 WORD e_cblp;     //Bytes on last page of file</span></span><br><span class="line">    <span class="comment">//0X04 WORD e_cp;       //Pages in file</span></span><br><span class="line">    <span class="comment">//0X06 WORD e_crlc;     //Relocations</span></span><br><span class="line">    <span class="comment">//0X08 WORD e_cparhdr;  //Size of header in paragraphs</span></span><br><span class="line">    <span class="comment">//0X0A WORD e_minalloc; //Minimun extra paragraphs needs</span></span><br><span class="line">    <span class="comment">//0X0C WORD e_maxalloc; //Maximun extra paragraphs needs</span></span><br><span class="line">    <span class="comment">//0X0E WORD e_ss;       //intial(relative)SS value</span></span><br><span class="line">    <span class="comment">//0X10 WORD e_sp;       //intial SP value</span></span><br><span class="line">    <span class="comment">//0X12 WORD e_csum;     //Checksum</span></span><br><span class="line">    <span class="comment">//0X14 WORD e_ip;       //intial IP value</span></span><br><span class="line">    <span class="comment">//0X16 WORD e_cs;       //intial(relative)CS value</span></span><br><span class="line">    <span class="comment">//0X18 WORD e_lfarlc;   //File Address of relocation table</span></span><br><span class="line">    <span class="comment">//0X1A WORD e_ovno;     //Overlay number</span></span><br><span class="line">    <span class="comment">//0x1C WORD e_res[4];   //Reserved words</span></span><br><span class="line">    <span class="comment">//0x24 WORD e_oemid;    //OEM identifier(for e_oeminfo)</span></span><br><span class="line">    <span class="comment">//0x26 WORD e_oeminfo;  //OEM information;e_oemid specific</span></span><br><span class="line">    <span class="comment">//0x28 WORD e_res2[10]; //Reserved words</span></span><br><span class="line">    <span class="number">0x3C</span> DWORD e_lfanew;    <span class="comment">//※Offset to start of PE header:定位PE文件，NT头相对于文件的偏移量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>e_magic : 固定为 ‘MZ’</p>
<p>e_lfanew：NT头的文件偏移位置</p>
<h3 id="DOS-stub"><a href="#DOS-stub" class="headerlink" title="DOS stub"></a>DOS stub</h3><p>​    由代码与数据混合而成，大小不固定，可没有，可存储在16位汇编指令，在dos环境下运行</p>
<h3 id="NT-头"><a href="#NT-头" class="headerlink" title="NT 头"></a>NT 头</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x86</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;                       <span class="comment">// 文件头</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;      	   <span class="comment">// 可选头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>

<p>Signature: 签名，50450000H ===&gt;  “PE00”</p>
<h3 id="NT-：文件头"><a href="#NT-：文件头" class="headerlink" title="NT ：文件头"></a>NT ：文件头</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x86 x64相同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;                           <span class="comment">// 运行平台  </span></span><br><span class="line">    WORD    NumberOfSections;				<span class="comment">// 节的数量</span></span><br><span class="line">    DWORD   TimeDateStamp;					<span class="comment">// 时间戳</span></span><br><span class="line">    DWORD   PointerToSymbolTable;			<span class="comment">// 符号表指针</span></span><br><span class="line">    DWORD   NumberOfSymbols;				<span class="comment">// 符号数量</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;			<span class="comment">// 可选头大小</span></span><br><span class="line">    WORD    Characteristics;                 <span class="comment">// 文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Machine：</p>
<ul>
<li>  0x014cH    x86</li>
<li>  0x0200H    Intel 64</li>
<li>  0x8664H    x64</li>
</ul>
</li>
<li><p>Characteristics:</p>
<ul>
<li>  0x0002H    可执行文件</li>
<li>  0x2000H    动态链接库</li>
<li>  0x1000H    系统文件</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">phrara</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/post/8e41db39/">http://example.com/post/8e41db39/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a></div><div class="post_share"><div class="social-share" data-image="/img/c4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/26cc52b5/"><img class="next-cover" src="/img/c9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Etcd 学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/photo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">phrara</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">到达世界最高城!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">汇编知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">汇编语言的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8086PC-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">8086PC 内存地址分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Debug%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">Debug程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">通用寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MOV-amp-ADD-amp-SUB-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">MOV &amp; ADD &amp; SUB 指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">地址寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CS-IP-%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">1.1.3.</span> <span class="toc-text">CS : IP 代码段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JMP-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">JMP 指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DS-Offset-%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">1.1.4.</span> <span class="toc-text">DS : [Offset] 数据段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SS-SP-%E5%A0%86%E6%A0%88%E6%AE%B5"><span class="toc-number">1.1.5.</span> <span class="toc-text">SS : SP 堆栈段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PUSH-amp-POP-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">PUSH &amp; POP 指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BX-amp-LOOP-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.</span> <span class="toc-text">[BX] &amp; LOOP 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#INC-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.1.</span> <span class="toc-text">INC 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DEC-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text">DEC 指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DW-%E4%BC%AA%E6%8C%87%E4%BB%A4-amp-start-%E6%A0%87%E5%8F%B7"><span class="toc-number">1.4.</span> <span class="toc-text">DW 伪指令 &amp; start 标号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">分段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">地址定位与数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AND-amp-OR-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.</span> <span class="toc-text">AND &amp; OR 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XOR-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.2.</span> <span class="toc-text">XOR 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B%E6%95%B0%E6%8D%AE-amp-DB-%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.3.</span> <span class="toc-text">字符串型数据 &amp; DB 伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E5%AE%9A%E4%BD%8D-amp-DI-amp-SI-amp-BP"><span class="toc-number">1.5.4.</span> <span class="toc-text">灵活定位 &amp; DI &amp; SI &amp; BP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X-PTR"><span class="toc-number">1.5.5.</span> <span class="toc-text">X PTR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DIV-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.6.</span> <span class="toc-text">DIV 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DD-%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.7.</span> <span class="toc-text">DD 伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DUP-%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.8.</span> <span class="toc-text">DUP 伪指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMP%E6%8C%87%E4%BB%A4%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">JMP指令原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OFFSET-%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.1.</span> <span class="toc-text">OFFSET 伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMP%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">JMP指令的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.3.</span> <span class="toc-text">有条件转移指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.</span> <span class="toc-text">栈操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RET-amp-RETF-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.7.1.</span> <span class="toc-text">RET &amp; RETF 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CALL-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.7.2.</span> <span class="toc-text">CALL 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BP%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">BP寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8E%8B%E6%A0%88"><span class="toc-number">1.7.4.</span> <span class="toc-text">参数压栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LEA-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.7.5.</span> <span class="toc-text">LEA 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MUL-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.7.6.</span> <span class="toc-text">MUL 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.7.</span> <span class="toc-text">寄存器冲突问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.8.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZF-%E6%A0%87%E5%BF%97"><span class="toc-number">1.8.2.</span> <span class="toc-text">ZF 标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PF-%E6%A0%87%E5%BF%97"><span class="toc-number">1.8.3.</span> <span class="toc-text">PF 标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SF-%E6%A0%87%E5%BF%97"><span class="toc-number">1.8.4.</span> <span class="toc-text">SF 标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF-%E6%A0%87%E5%BF%97"><span class="toc-number">1.8.5.</span> <span class="toc-text">CF 标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OF-%E6%A0%87%E5%BF%97"><span class="toc-number">1.8.6.</span> <span class="toc-text">OF 标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADC-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.7.</span> <span class="toc-text">ADC 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SBB-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.8.</span> <span class="toc-text">SBB 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMP-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.9.</span> <span class="toc-text">CMP 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TEST-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.10.</span> <span class="toc-text">TEST 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9B%B8%E5%85%B3%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.11.</span> <span class="toc-text">与标志位相关的条件转移指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DF-%E6%A0%87%E5%BF%97-amp-%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.12.</span> <span class="toc-text">DF 标志 &amp; 串传送指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MOVSB-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.12.1.</span> <span class="toc-text">MOVSB 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MOVSW-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.12.2.</span> <span class="toc-text">MOVSW 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-REP-%E7%9A%84%E9%85%8D%E5%90%88"><span class="toc-number">1.8.12.3.</span> <span class="toc-text">与 REP 的配合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLD-amp-STD-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.12.4.</span> <span class="toc-text">CLD &amp; STD 指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PUSHF-amp-POPF-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.13.</span> <span class="toc-text">PUSHF &amp; POPF 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E5%9C%A8Debug%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.8.14.</span> <span class="toc-text">标志寄存器在Debug中的表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E4%B8%AD%E6%96%AD"><span class="toc-number">1.9.</span> <span class="toc-text">内中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32%E4%BD%8D%E9%80%86%E5%90%91"><span class="toc-number">2.</span> <span class="toc-text">32位逆向</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%AB%AF%E5%BA%8F-amp-%E5%A4%A7%E7%AB%AF%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">小端序&amp;大端序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IA-32%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">IA-32寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本程序运行寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7"><span class="toc-number">2.3.</span> <span class="toc-text">栈帧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">PE文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOS-%E5%A4%B4"><span class="toc-number">2.4.1.</span> <span class="toc-text">DOS 头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOS-stub"><span class="toc-number">2.4.2.</span> <span class="toc-text">DOS stub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NT-%E5%A4%B4"><span class="toc-number">2.4.3.</span> <span class="toc-text">NT 头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NT-%EF%BC%9A%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="toc-number">2.4.4.</span> <span class="toc-text">NT ：文件头</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/8e41db39/" title="汇编语言"><img src="/img/c4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="汇编语言"/></a><div class="content"><a class="title" href="/post/8e41db39/" title="汇编语言">汇编语言</a><time datetime="2022-09-08T13:27:48.000Z" title="Created 2022-09-08 21:27:48">2022-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/26cc52b5/" title="Etcd 学习"><img src="/img/c9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Etcd 学习"/></a><div class="content"><a class="title" href="/post/26cc52b5/" title="Etcd 学习">Etcd 学习</a><time datetime="2022-09-08T03:25:32.000Z" title="Created 2022-09-08 11:25:32">2022-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/0/" title="Go-zero框架学习"><img src="/img/c8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go-zero框架学习"/></a><div class="content"><a class="title" href="/post/0/" title="Go-zero框架学习">Go-zero框架学习</a><time datetime="2022-09-07T14:10:18.203Z" title="Created 2022-09-07 22:10:18">2022-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4a17b156/" title="Hello World"><img src="/img/c9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/post/4a17b156/" title="Hello World">Hello World</a><time datetime="2022-09-07T13:50:14.377Z" title="Created 2022-09-07 21:50:14">2022-09-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/c4.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By phrara</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>